#!/bin/ruby
# coding: utf-8

require 'oily_png'  # ubuntu package ruby-oily-png
require 'json' # ubuntu package ruby-zip
require 'zip'
require 'set'

require_relative "lib/job"
require_relative "lib/verbing"
require_relative "lib/spatter"
require_relative "lib/pearls"
require_relative "lib/match"
require_relative "lib/learn"
require_relative "lib/page"
require_relative "lib/freak"
require_relative "lib/fft"
require_relative "lib/estimate_scale"
require_relative "lib/image_util"
require_relative "lib/fat"
require_relative "lib/font"
require_relative "lib/fontconfig"
require_relative "lib/script"
require_relative "lib/pat"
require_relative "lib/fset"
require_relative "lib/correl"
require_relative "lib/clustering"
require_relative "lib/tempfile"
require_relative "lib/file_util"
require_relative "lib/tuning"
require_relative "lib/smp"
require_relative "lib/graphing"
require_relative "lib/estimate_image_params"
require_relative "lib/stat"
require_relative "lib/other_interpreters"
require_relative "lib/string_util"
require_relative "lib/array_util"
require_relative "lib/clown"
require_relative "lib/box"
require_relative "lib/reports"
require_relative "lib/svg"
require_relative "lib/pdf"
require_relative "lib/ttf"
require_relative "lib/test"

class HomeDir
  # This code can't go in a file inside the lib subdirectory, because when code is executed from there, __dir__ has the wrong value.
  @@no_place_like = __dir__
  def HomeDir.home
    return @@no_place_like
  end
end


def main()
  start = Time.now

  if ARGV.length==0 then die("see README for usage") end

  if ARGV.length>1 or !(ARGV[0]=~/\.job$/)then
    verbing(ARGV)
    exit(0)
  end

  job_file = ARGV[0] # can be '-' for stdin
  job_list = Job.list_from_file(job_file)
  if job_list.length<1 then die("empty list of pages in job file") end
  job=job_list[0].without_image_info
  if job_list.length==1 then summary=job_list[0].to_s else summary=job.to_s end
  print "Parameters for this job:#{summary}\n"

  report_dir = dir_and_file_to_path(job.output,"_reports")
  job.output = create_directories(job.output,report_dir)
  create_text_file(dir_and_file_to_path(job.output,"_this.job"),slurp_file(job_file)) # copy job file so we have a record of it
  if !(job.set.nil?) then
    copy_all_pat_files(job.set,job.output) # copy pat files from previous run; these may get overwritten later
  end

  results = []
  count = 0
  job_list.each { |one_page_job|
    count += 1
    if job_list.length>1 then print "======\nProcessing page image #{one_page_job.image}, page #{count} of #{job_list.length}.\n======\n" end
    page = Page.from_file(one_page_job.image) # handles extracting a page from a pdf, if that syntax was used
    one_page_job.image = page.png_filename
    page.analyze(one_page_job.spacing_multiple,one_page_job.guess_dpi,one_page_job.guess_font_size)
    results.push(run_job(one_page_job,page,report_dir))
  }
  postprocess(job,results,report_dir)

  finish = Time.now
  print "Total time for this entire run = #{finish-start} seconds.\n"
end

def run_job(job,page,report_dir)
  # Process a single page.
  if job.verb=='ocr' then
    all_chars = job.all_characters
    if all_chars.nil? then
      m = Match.new(scripts:['latin','greek'],meta_threshold:job.threshold)
    else
      m = Match.new(characters:all_chars,meta_threshold:job.threshold)
    end
    if job.set.nil? then die("job file doesn't contain a set parameter specifying a pattern set") end
    hits = m.execute(page,job.set,batch_code:Process.pid.to_s) # only result of doing this is currently that mon.png gets written
    spatter = Spatter.from_hits_page_and_set(hits,page,job.set)
    print "spatter:\n  #{spatter.report}\n"
    lines = spatter.plow()
    #lines.each { |l|      print "line:\n  #{l.report}\n"    }
    lines.each { |l| print babble(l),"\n"  }
    lines.each { |l| print mumble(l),"\n"  }
    return
  end
  if job.verb=='seed' then
    return create_pats_no_matching(job,page)
  end
  if job.verb=='learn' then
    return extract_matching_swatches(job,page,report_dir) # a hash whose keys are characters and whose values are of the form [hits,images]
  end
  die("unrecognized verb: #{job.verb}")
end

def postprocess(job,results,report_dir)
  # Job can be a generic Job object without any image.
  if job.verb=='ocr' then 
    return
  end
  if job.verb=='seed' then
    write_svg_reports(job,report_dir)
    return
  end
  if job.verb=='learn' then
    postprocess_learn(job,results,report_dir)
    return
  end
  die("unrecognized verb #{job.verb}")
end

def die(message)
  #  $stderr.print message,"\n"
  raise message # gives a stack trace
  exit(-1)
end

def warn(message)
  $stderr.print "****************************************************************************************************************\n"
  $stderr.print "              WARNING\n"
  $stderr.print message,"\n"
  $stderr.print "****************************************************************************************************************\n"
end

main()

