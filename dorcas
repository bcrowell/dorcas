#!/bin/ruby
# coding: utf-8

require 'oily_png'  # ubuntu package ruby-oily-png
require 'json' # ubuntu package ruby-zip
require 'zip'

require_relative "lib/job"
require_relative "lib/match"
require_relative "lib/fft"
require_relative "lib/estimate_scale"
require_relative "lib/image_util"
require_relative "lib/font"
require_relative "lib/fontconfig"
require_relative "lib/script"
require_relative "lib/pat"
require_relative "lib/correl"
require_relative "lib/clustering"
require_relative "lib/tempfile"
require_relative "lib/file_util"
require_relative "lib/constants"
require_relative "lib/smp"
require_relative "lib/graphing"
require_relative "lib/estimate_image_params"
require_relative "lib/stat"
require_relative "lib/other_interpreters"
require_relative "lib/string_util"
require_relative "lib/array_util"
require_relative "lib/reports"
require_relative "lib/svg"
require_relative "lib/ttf"

def main()

  job_file = ARGV[0]
  job = Job.from_file(job_file)
  print "Parameters for this job:#{job}\n"

  text_file = job.image
  spacing_multiple = job.spacing_multiple
  threshold = job.threshold
  cluster_threshold = job.cluster_threshold 
  fudge_size = job.adjust_size
  output_dir = job.output

  report_dir = dir_and_file_to_path(output_dir,"_reports")
  temp_dir,output_dir = create_directories(output_dir,report_dir)

  # Tell them what seed fonts we understood them as requesting. If they gave a name that doesn't work, fontconfig will
  # fall back to something stupid. We try to detect that and warn them.
  # Build a hash all_fonts whose keys are the user-supplied strings and whose values are Font objects.
  all_fonts = {}
  script_and_case_to_font_name = {}
  print "Fonts:\n"
  job.seed_fonts.each { |x|
    s = x[0] # may be a font name or a ttf filename
    script_and_case_to_font_name["#{x[1]}***#{x[2]}"] = s # key is like greek***lowercase
    file = Job.font_string_to_path(s)
    if Job.font_string_is_full_path(s) then
      print "  #{s}\n"
    else
      print "  #{s} -> #{file}\n"
      round_trip = Fontconfig.path_to_name(file)
      if round_trip!=s then
        warn("In #{job_file}, the font name '#{s}' does not match the name '#{round_trip}' of the file supplied by fontconfig.\n"+
               "This probably means either that you don't have the font on your system or that you gave the wrong name or a different form of the name.")
      end
    end
    if not (all_fonts.has_key?(s)) then
      all_fonts[s] = Font.new(file_path:file)
    end
  }

  text,stats,peak_to_bg,dpi = analyze_text_image(text_file,spacing_multiple,job.guess_dpi,job.guess_font_size)

  pats = []
  job.characters.each { |x|
    # x looks like ["greek","lowercase","αβγδε"]. The string of characters at the end has already been filled in by initializer, if necessary.
    script_name,c,chars = x 
    font_name = script_and_case_to_font_name["#{script_name}***#{c}"]
    seed_font = all_fonts[font_name]
    script = Script.new(script_name)
    dpi = match_seed_font_scale(seed_font,stats,script,fudge_size)
    print "  #{script_name} #{c} #{chars} #{font_name} #{dpi.round} dpi\n"
    print "  metrics: #{seed_font.metrics(dpi,script)}\n"
    chars.chars.each { |char|
      name = char_to_short_name(char)
      matches_svg_file = dir_and_file_to_path(report_dir,"matches_#{name}.svg")
      pat,hits = match_character(char,text,text_file,temp_dir,job.prev,output_dir,seed_font,dpi,script,threshold,stats,cluster_threshold,
                                 report_dir,matches_svg_file,name)
      if not (pat.nil?) then pats.push([true,pat]) else pats.push([false,char]) end
    }
  }

  patset_svg_dir = report_dir
  patset_svg_file = "patterns.svg"
  print "Writing a summary of swatches to #{dir_and_file_to_path(patset_svg_dir,patset_svg_file)}\n"
  patset_as_svg(patset_svg_dir,patset_svg_file,pats)

end

def match_character(char,text,text_file,temp_dir,prev_dir,output_dir,f,dpi,script,threshold,stats,cluster_threshold,report_dir,matches_svg_file,char_name)
  verbosity = 2
  # returns nil if there's no match
  print "Searching for character #{char} in text file #{text_file}\n"
  pat_from_prev = false
  if !(prev_dir.nil?) then
    prev_pat_filename = Pat.char_to_filename(prev_dir,char)
    pat_from_prev = File.exists?(prev_pat_filename)
  end
  if pat_from_prev then
    if verbosity>=2 then print "  Taking pattern from previous run, swatch in #{prev_pat_filename}\n" end
    pat = Pat.from_file(prev_pat_filename)
  else
    if verbosity>=2 then print "  Generating new character from seed font.\n" end
    pat = char_to_pat(char,temp_dir,f,dpi,script,char)
  end
  if verbosity>=3 then print "pat.line_spacing=#{pat.line_spacing}, bbox=#{pat.bbox}\n" end

  hits = match(text,pat,stats,threshold)
  matches_as_svg(report_dir,matches_svg_file,char_name,text_file,text,pat,hits)
  composite = swatches(hits,text,pat,stats,char,cluster_threshold)
  if composite.nil? then print "  no matches found for #{char}\n"; return end
  pat.transplant(composite)
  pat.save(Pat.char_to_filename(output_dir,char))
  return [pat,hits]
end

def analyze_text_image(text_file,spacing_multiple,guess_dpi,guess_font_size)
  text = ChunkyPNG::Image.from_file(text_file)
  print "Input file is #{text_file}\n"
  stats = ink_stats_1(text)
  peak_to_bg = stats['dark']/stats['submedian']
  text_line_spacing,x_height = estimate_scale(text,peak_to_bg,spacing_multiple:spacing_multiple,guess_dpi:guess_dpi,guess_font_size:guess_font_size)
  stats['line_spacing'] = text_line_spacing
  stats['x_height'] = x_height
  stats = ink_stats_2(text,stats,(text_line_spacing*0.3).round)
  print "ink stats:\n#{stats_to_string(stats)}"
  if x_height<0.35*text_line_spacing/spacing_multiple then 
    warn("x-height appears to be small compared to line spacing for spacing_multiple=#{spacing_multiple}")
  end
  stats['background'] = stats['submedian'] # background ink level of text, in ink units

  # The result of all this is that text_line_spacing is quite robust and fairly precise, whereas x_height is
  # total crap, should probably not be used for anything more than the warning above.
  # Although the value of text_line_spacing is good, the way I'm using it in setting the font size is
  # not super great, sometimes results in a font whose size is wrong by 15%.

  return [text,stats,peak_to_bg]
end

def match_seed_font_scale(font,stats,script,fudge_size)
  # estimate scale so that pattern has resolution approximately equal to that of text
  text_line_spacing = stats['line_spacing']*fudge_size
  dpi = 300 # initial guess
  dpi = (dpi*text_line_spacing.to_f/font.line_spacing_pixels(dpi,script).to_f).round

  return dpi
end

def create_directories(output_dir,report_dir)
  temp_dir = 'temp'
  if not File.exists?(temp_dir) then Dir.mkdir(temp_dir) end
  if not File.exists?(output_dir) then Dir.mkdir(output_dir) end
  return [temp_dir,output_dir]
end

def die(message)
  #  $stderr.print message,"\n"
  raise message # gives a stack trace
  exit(-1)
end

def warn(message)
  $stderr.print "****************************************************************************************************************\n"
  $stderr.print "              WARNING\n"
  $stderr.print message,"\n"
  $stderr.print "****************************************************************************************************************\n"
end

main()

