#!/bin/ruby
# coding: utf-8

require 'oily_png'
  # ubuntu package ruby-oily-png
require 'json'
require 'zip'

require_relative "lib/job"
require_relative "lib/match"
require_relative "lib/fft"
require_relative "lib/estimate_scale"
require_relative "lib/image_util"
require_relative "lib/font"
require_relative "lib/script"
require_relative "lib/pat"
require_relative "lib/correl"
require_relative "lib/clustering"
require_relative "lib/tempfile"
require_relative "lib/file_util"
require_relative "lib/constants"
require_relative "lib/smp"
require_relative "lib/graphing"
require_relative "lib/estimate_image_params"
require_relative "lib/stat"
require_relative "lib/other_interpreters"
require_relative "lib/string_util"
require_relative "lib/array_util"
require_relative "lib/reports"
require_relative "lib/svg"
require_relative "lib/ttf"

def main()

  job_file = ARGV[0]
  job = Job.from_file(job_file)
  print "Parameters for this job:#{job}\n"

  text_file = job.image
  spacing_multiple = job.spacing_multiple
  threshold = job.threshold
  cluster_threshold = job.cluster_threshold 
  fudge_size = job.adjust_size
  output_dir = job.output

  temp_dir,output_dir = create_directories(output_dir)

  # Tell them what seed fonts we understood them as requesting. If they gave a name that doesn't work, fontconfig will
  # fall back to something stupid. We try to detect that and warn them.
  # Build a hash all_fonts whose keys are the user-supplied strings and whose values are Font objects.
  all_fonts = {}
  print "Fonts:\n"
  job.seed_fonts.each { |x|
    s = x[0] # may be a font name or a ttf filename
    file = Job.font_string_to_path(s)
    if Job.font_string_is_full_path(s) then
      print "  #{s}\n"
    else
      print "  #{s} -> #{file}\n"
      round_trip = Font.path_to_name(file)
      if round_trip!=s then
        warn("In #{job_file}, the font name '#{s}' does not match the name '#{round_trip}' of the file supplied by fontconfig.\n"+
               "This probably means either that you don't have the font on your system or that you gave the wrong name or a different form of the name.")
      end
    end
    if not (all_fonts.has_key?(s)) then all_fonts[s] = Font.new(file_path:file) end
  }

  # Tell them what characters they requested.
  print "Characters:\n"
  job.characters.each { |x|
    script,c,string = x # string has already been filled in by initializer, if necessary
    print "  #{script} #{c} #{string}\n"
  }

  script = Script.new('greek')
  warn("using greek rather than script given in job file")

  seed_font = all_fonts[all_fonts.keys[0]]
  warn("using first font listed")

  text,stats,peak_to_bg,dpi = analyze_text_image(text_file,script,spacing_multiple)
  dpi = match_seed_font_scale(seed_font,stats,script,fudge_size)

  print seed_font
  print "metrics for seed font: #{seed_font.metrics(dpi,script)}\n"
  print script,"\n"

  pats = []
  chars = job.characters[0][2]
  warn("usig first element of characters")
  chars.chars.each { |char|
    pat = match_character(char,text,text_file,temp_dir,output_dir,seed_font,dpi,script,threshold,stats,cluster_threshold)
    pats.push(pat)
  }
  patset_as_svg("b","b.svg",pats)

end

def match_character(char,text,text_file,temp_dir,output_dir,f,dpi,script,threshold,stats,cluster_threshold)
  print "Searching for character #{char} in text file #{text_file}\n"
  pat = char_to_pat(char,temp_dir,f,dpi,script,char)
  print "pat.line_spacing=#{pat.line_spacing}, bbox=#{pat.bbox}\n"
  pat.bw.save('bw.png') # needed later to build svg
  pat.red.save('red.png')

  hits = match(text,pat,stats,threshold)
  matches_as_svg('a.svg',text_file,text,pat,hits)
  image = swatches(hits,text,pat,stats,char,cluster_threshold)
  if image.nil? then print "  no matches found for #{char}\n"; return end
  name = char_to_short_name(char)
  image.save(dir_and_file_to_path(output_dir,name+".png"))
  pat.save(dir_and_file_to_path(output_dir,name+".pat"))
  return pat
end

def analyze_text_image(text_file,script,spacing_multiple)
  text = ChunkyPNG::Image.from_file(text_file)
  print "Input file is #{text_file}\n"
  stats = ink_stats_1(text)
  peak_to_bg = stats['dark']/stats['submedian']
  text_line_spacing,x_height = estimate_scale(text,peak_to_bg,spacing_multiple:spacing_multiple)
  stats['line_spacing'] = text_line_spacing
  stats['x_height'] = x_height
  stats = ink_stats_2(text,stats,(text_line_spacing*0.3).round)
  print "ink stats:\n#{stats_to_string(stats)}"
  if x_height<0.35*text_line_spacing/spacing_multiple then 
    warn("x-height appears to be small compared to line spacing for spacing_multiple=#{spacing_multiple}")
  end
  stats['background'] = stats['submedian'] # background ink level of text, in ink units

  # The result of all this is that text_line_spacing is quite robust and fairly precise, whereas x_height is
  # total crap, should probably not be used for anything more than the warning above.
  # Although the value of text_line_spacing is good, the way I'm using it in setting the font size is
  # not super great, sometimes results in a font whose size is wrong by 15%.

  return [text,stats,peak_to_bg]
end

def match_seed_font_scale(font,stats,script,fudge_size)
  # estimate scale so that pattern has resolution approximately equal to that of text
  text_line_spacing = stats['line_spacing']*fudge_size
  dpi = 300 # initial guess
  dpi = (dpi*text_line_spacing.to_f/font.line_spacing_pixels(dpi,script).to_f).round

  return dpi
end

def create_directories(output_dir)
  temp_dir = 'temp'
  if not File.exists?(temp_dir) then Dir.mkdir(temp_dir) end
  if not File.exists?(output_dir) then Dir.mkdir(output_dir) end
  return [temp_dir,output_dir]
end

def die(message)
  #  $stderr.print message,"\n"
  raise message # gives a stack trace
  exit(-1)
end

def warn(message)
  $stderr.print "****************************************************************************************************************\n"
  $stderr.print "              WARNING\n"
  $stderr.print message,"\n"
  $stderr.print "****************************************************************************************************************\n"
end

main()

