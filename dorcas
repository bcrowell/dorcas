#!/bin/ruby
# coding: utf-8

require 'oily_png'  # ubuntu package ruby-oily-png
require 'json' # ubuntu package ruby-zip
require 'zip'
require 'set'

require_relative "lib/job"
require_relative "lib/verbing"
require_relative "lib/match"
require_relative "lib/learn"
require_relative "lib/page"
require_relative "lib/freak"
require_relative "lib/fft"
require_relative "lib/estimate_scale"
require_relative "lib/image_util"
require_relative "lib/font"
require_relative "lib/fontconfig"
require_relative "lib/script"
require_relative "lib/pat"
require_relative "lib/fset"
require_relative "lib/correl"
require_relative "lib/clustering"
require_relative "lib/tempfile"
require_relative "lib/file_util"
require_relative "lib/tuning"
require_relative "lib/smp"
require_relative "lib/graphing"
require_relative "lib/estimate_image_params"
require_relative "lib/stat"
require_relative "lib/other_interpreters"
require_relative "lib/string_util"
require_relative "lib/array_util"
require_relative "lib/box"
require_relative "lib/reports"
require_relative "lib/svg"
require_relative "lib/pdf"
require_relative "lib/ttf"
require_relative "lib/test"

def main()
  start = Time.now

  if ARGV.length==0 then die("see README for usage") end

  if ARGV.length>1 or !(ARGV[0]=~/\.job$/)then
    verbing(ARGV)
    exit(0)
  end

  job_file = ARGV[0] # can be '-' for stdin
  job_list = Job.list_from_file(job_file)
  if job_list.length<1 then die("empty list of pages in job file") end
  job=job_list[0].without_image_info
  if job_list.length==1 then summary=job_list[0].to_s else summary=job.to_s end
  print "Parameters for this job:#{summary}\n"

  report_dir = dir_and_file_to_path(job.output,"_reports")
  job.output = create_directories(job.output,report_dir)
  create_text_file(dir_and_file_to_path(job.output,"_this.job"),slurp_file(job_file)) # copy job file so we have a record of it
  if !(job.set.nil?) then
    copy_all_pat_files(job.set,job.output) # copy pat files from previous run; these may get overwritten later
  end

  results = []
  count = 0
  job_list.each { |one_page_job|
    count += 1
    if job_list.length>1 then print "Processing page image #{one_page_job.image}, page #{count} of #{job_list.length}.\n" end
    page = Page.from_file(one_page_job.image) # handles extracting a page from a pdf, if that syntax was used
    one_page_job.image = page.png_filename
    page.analyze(one_page_job.spacing_multiple,one_page_job.guess_dpi,one_page_job.guess_font_size)
    results.push(run_job(one_page_job,page,report_dir))
  }
  postprocess(job,results,report_dir)

  finish = Time.now
  print "Total time for this entire run = #{finish-start} seconds.\n"
end

def run_job(job,page,report_dir)
  if job.verb=='ocr' then
    all_chars = job.all_characters
    if all_chars.nil? then
      m = Match.new(scripts:['latin','greek'],meta_threshold:job.threshold)
    else
      m = Match.new(characters:all_chars,meta_threshold:job.threshold)
    end
    if job.set.nil? then die("job file doesn't contain a set parameter specifying a pattern set") end
    m.execute(page,job.set,batch_code:Process.pid.to_s)
    return
  end
  if job.verb=='seed' then
    return_pats_no_matching(job,page)
  end
  if job.verb=='learn' then
    return extract_matching_swatches(job,page,report_dir) # a hash whose keys are characters and whose values are of the form [hits,images]
  end
  die("unrecognized verb: #{job.verb}")
end

def postprocess(job,results,report_dir)
  # Job can be a generic Job object without any image.
  if job.verb=='ocr' then 
    return
  end
  if job.verb=='seed' then
    die("do I need protprocessing for seed verb? are there applicable svg reports?")
    return
  end
  if job.verb=='learn' then
    postprocess_learn(job,results,report_dir)
    return
  end
  die("unrecognized verb #{job.verb}")
end

def postprocess_learn(job,results,report_dir,verbosity:1)
  # Results is a list, each of whose elements is a hash whose keys are characters and whose values are of the form [hits,images].
  # Start by merging these into a single hash whose keys are characters and whose values are lists of elements of the form [pagenum,hits,images].
  results2 = {}
  count = 0
  results.each { |results_one_page|
    results_one_page.each { |char,v|
      hits,images = v                                                                                                                                       
      if !(images.nil?) then 
        if !(results2.has_key?(char)) then results2[char] = [] end
        results2[char].push([count,hits,images])
      end
    }
    count += 1
  }
  results2.each { |char,l|
    # l should be a list of elements of the form [pagenum,hits,images].
    pagenum,hits,images = l
    if images.nil? then n_matches=0 else n_matches=images.length end
    print "postprocessing character #{char}\n"
    all_images = []
    l.each { |p|
      pagenum,hits,images = p
      next if images.nil? || images.length==0
      all_images.concat(images)
    }
    if verbosity>=1 then print "  learn mode, char=#{char}, number of matches = #{all_images.length}\n" end
    next if all_images.length==0
    if verbosity>=1 && all_images.length==1 then print "  only one match, nothing to do\n" end
    next if all_images.length==1
    # Analyze them into clusters.
    clusters = find_clusters_of_swatches(all_images,char,job.cluster_threshold)
    cl_averages = make_composite_from_swatches(all_images,clusters)
    composite = clustering_helper(job.prefer_cluster,cl_averages,char,verbosity:verbosity)
    print "  Transplanting composite into pat, #{char}.\n" # qwe
    pat = job.set.pat(char)
    pat.transplant(composite)
    pat.save(Pat.char_to_filename(job.output,char))
    char_name = char_to_short_name(char)
    svg_filename = dir_and_file_to_path(report_dir,"composites_#{char_name}.svg")
    summarize_composites_as_svg(report_dir,svg_filename,char_name,cl_averages)
  }
  return
end

def clustering_helper(force_cl,composites,char,verbosity:1)
  if force_cl.nil? then
    composite = composites[0]
  else
    if force_cl<0 or force_cl>composites.length-1 then
      die("illegal value in prefer_cluster, [\"#{char}\",#{force_cl+1}], only #{composites.length} clusters found")
    end
    composite = composites[force_cl]
    if verbosity>=1 then print "  Forcing a match to cluster #{force_cl+1}.\n" end
  end
  return composite
end

def die(message)
  #  $stderr.print message,"\n"
  raise message # gives a stack trace
  exit(-1)
end

def warn(message)
  $stderr.print "****************************************************************************************************************\n"
  $stderr.print "              WARNING\n"
  $stderr.print message,"\n"
  $stderr.print "****************************************************************************************************************\n"
end

main()

